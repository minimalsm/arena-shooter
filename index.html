<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate" />
    <meta http-equiv="Pragma" content="no-cache" />
    <meta http-equiv="Expires" content="0" />
    <title>Arena Shooter Prototype</title>
    <style>
        body { 
            margin: 0; 
            overflow: hidden; 
            font-family: Arial, sans-serif;
            background-color: #000;
        }
        #gameCanvas { 
            display: block; 
            width: 100%;
            height: 100%;
            cursor: crosshair;
        }
        #hud {
            position: absolute;
            bottom: 20px;
            left: 20px;
            color: white;
            font-size: 18px;
            text-shadow: 1px 1px 1px #000;
            pointer-events: none;
        }
        #crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 20px;
            height: 20px;
            margin-left: -10px;
            margin-top: -10px;
            color: white;
            font-size: 24px;
            text-align: center;
            user-select: none;
            pointer-events: none;
        }
        #health-bar {
            position: absolute;
            bottom: 20px;
            right: 20px;
            width: 200px;
            height: 20px;
            background-color: #333;
            border: 2px solid #666;
            pointer-events: none;
        }
        #health-fill {
            height: 100%;
            width: 100%;
            background-color: #0f0;
            transition: width 0.3s;
        }
        #ammo {
            position: absolute;
            bottom: 50px;
            right: 20px;
            color: white;
            font-size: 18px;
            text-shadow: 1px 1px 1px #000;
            pointer-events: none;
        }
        #score {
            position: absolute;
            top: 20px;
            right: 20px;
            color: white;
            font-size: 24px;
            text-shadow: 1px 1px 1px #000;
            pointer-events: none;
        }
        #instructions {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            background-color: rgba(0,0,0,0.5);
            padding: 10px;
            border-radius: 5px;
            z-index: 10;
            pointer-events: none;
        }
        #start-menu {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: white;
            z-index: 100;
        }
        #start-button {
            background-color: #4CAF50;
            border: none;
            color: white;
            padding: 15px 32px;
            text-align: center;
            text-decoration: none;
            display: inline-block;
            font-size: 16px;
            margin: 20px;
            cursor: pointer;
            border-radius: 5px;
        }
        #game-over {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: white;
            z-index: 100;
        }
        #restart-button {
            background-color: #4CAF50;
            border: none;
            color: white;
            padding: 15px 32px;
            text-align: center;
            text-decoration: none;
            display: inline-block;
            font-size: 16px;
            margin: 20px;
            cursor: pointer;
            border-radius: 5px;
        }
        .final-score {
            font-size: 24px;
            margin: 10px;
        }
        #version-display {
            position: absolute;
            top: 5px;
            left: 5px;
            color: rgba(255,255,255,0.5);
            font-size: 12px;
            z-index: 100;
            pointer-events: none;
        }
    </style>
</head>
<body>
    <div id="version-display">v1.1.2</div>
    <div id="crosshair">+</div>
    <div id="hud">
        <div id="weapon-info">Current Weapon: Basic Blaster</div>
        <div id="pickup-info"></div>
    </div>
    <div id="health-bar"><div id="health-fill"></div></div>
    <div id="ammo">Ammo: 100</div>
    <div id="score">Score: 0</div>
    <div id="instructions">WASD to move | SPACE to jump | Move mouse to aim | Click to shoot | 1-3 to switch weapons | 0 to toggle debug</div>
    
    <div id="start-menu">
        <h1>Arena Shooter</h1>
        <p>A UT99-inspired browser shooter</p>
        <div style="margin: 20px 0;">
            <label for="ai-count">AI Players: </label>
            <select id="ai-count" style="padding: 5px; margin-right: 15px;">
                <option value="0">None</option>
                <option value="1" selected>1</option>
                <option value="2">2</option>
                <option value="3">3</option>
                <option value="4">4</option>
            </select>
            
            <label for="ai-difficulty">Difficulty: </label>
            <select id="ai-difficulty" style="padding: 5px;">
                <option value="EASY">Easy</option>
                <option value="MEDIUM" selected>Medium</option>
                <option value="HARD">Hard</option>
                <option value="INSANE">Insane</option>
            </select>
        </div>
        <button id="start-button">Start Game</button>
        <p><a href="instructions.html" style="color: #4CAF50; text-decoration: none; margin-top: 10px; display: inline-block;">View Instructions</a></p>
    </div>
    
    <div id="game-over">
        <h1>Game Over</h1>
        <div class="final-score">Final Score: 0</div>
        <button id="restart-button">Play Again</button>
    </div>
    
    <canvas id="gameCanvas"></canvas>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/0.149.0/three.min.js"></script>
    <script>
        // Game version - increment this when making changes
        const GAME_VERSION = "1.1.2";
        
        // Game variables
        let scene, camera, renderer;
        let player, playerDirection;
        let moveForward = false, moveBackward = false, moveLeft = false, moveRight = false;
        let jumping = false, canJump = true;  // Add jumping variables
        let prevTime = performance.now();
        let velocity = new THREE.Vector3();
        let direction = new THREE.Vector3();
        let pickups = [];
        let enemies = [];
        let projectiles = [];
        let aiPlayers = []; // Array to store AI players
        let gameStarted = false;
        let frameId = null;
        let health = 100;
        let lastShotTime = 0;
        let score = 0;
        let enemyTypes = ['basic', 'fast', 'tank'];
        let debugMode = false;
        
        // AI difficulty levels
        const AI_DIFFICULTY = {
            EASY: { reactionTime: 1000, accuracy: 0.5, movementRandomness: 0.7 },
            MEDIUM: { reactionTime: 700, accuracy: 0.7, movementRandomness: 0.5 },
            HARD: { reactionTime: 400, accuracy: 0.85, movementRandomness: 0.3 },
            INSANE: { reactionTime: 200, accuracy: 0.95, movementRandomness: 0.1 }
        };
        
        // Movement speed
        const MOVE_SPEED = 0.15;
        const TURN_SPEED = 0.05;
        const JUMP_FORCE = 0.25;  // Jump force
        const GRAVITY = 0.01;     // Gravity force
        
        // Player direction (in radians)
        let playerRotation = 0;
        
        // Weapon system
        const weapons = {
            blaster: { 
                name: "Basic Blaster", 
                damage: 10, 
                ammo: 100, 
                maxAmmo: 100, 
                fireRate: 5, 
                active: true,
                projectileColor: 0x00ffff,
                projectileSize: 0.1,
                projectileSpeed: 1.0,
                projectileCount: 1
            },
            shotgun: { 
                name: "Shotgun", 
                damage: 15, 
                ammo: 0, 
                maxAmmo: 30, 
                fireRate: 2, 
                active: false,
                projectileColor: 0xff9900,
                projectileSize: 0.05,
                projectileSpeed: 1.2,
                projectileCount: 8,
                spread: 0.2
            },
            rocketLauncher: { 
                name: "Rocket Launcher", 
                damage: 50, 
                ammo: 0, 
                maxAmmo: 10, 
                fireRate: 1, 
                active: false,
                projectileColor: 0xff0000,
                projectileSize: 0.2,
                projectileSpeed: 0.8,
                projectileCount: 1,
                explosive: true,
                explosionRadius: 3
            }
        };
        
        // Mouse control variables
        const pitchObject = new THREE.Object3D(); // For looking up/down
        const yawObject = new THREE.Object3D();   // For looking left/right
        let targetYaw = 0;
        let targetPitch = 0;
        let currentYaw = 0;
        let currentPitch = 0;
        let mouseSensitivity = 0.002;
        
        // Weapon models
        let weaponModels = {};
        let currentWeaponModel = null;
        
        // Track all obstacles for collision detection
        let obstacles = [];
        
        // Initialize game
        function init() {
            // Update version display
            document.getElementById('version-display').textContent = `v${GAME_VERSION}`;
            
            // Create scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x222222);
            scene.fog = new THREE.Fog(0x222222, 0, 500);
            
            // Create camera
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            
            // Setup player control objects
            pitchObject.add(camera);
            yawObject.position.y = 1.6; // Player height
            yawObject.position.x = -10; // Start away from center
            yawObject.position.z = -10; // Start away from center
            yawObject.add(pitchObject);
            scene.add(yawObject);
            
            // Create weapon models
            createWeaponModels();
            
            // Create debug toggle button
            createDebugToggleButton();
            
            // Add dedicated debug mode toggle listener
            window.addEventListener('keydown', function(event) {
                // Check for debug toggle keys (0, backtick, numpad 0)
                if (event.key === '0' || event.key === '`' || event.keyCode === 48 || 
                    event.keyCode === 96 || event.keyCode === 192) {
                    toggleDebugMode();
                    event.preventDefault(); // Prevent default browser behavior
                }
            });
            
            // Create renderer
            renderer = new THREE.WebGLRenderer({ canvas: document.getElementById('gameCanvas'), antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            
            // Setup lighting
            const ambientLight = new THREE.AmbientLight(0x404040);
            scene.add(ambientLight);
            
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(1, 1, 1);
            directionalLight.castShadow = true;
            directionalLight.shadow.mapSize.width = 2048;
            directionalLight.shadow.mapSize.height = 2048;
            scene.add(directionalLight);
            
            // Create level
            createLevel();
            
            // Setup event listeners
            setupEventListeners();
            
            // Start button event listener
            document.getElementById('start-button').addEventListener('click', startGame);
            
            // Restart button event listener
            document.getElementById('restart-button').addEventListener('click', restartGame);
        }
        
        function createLevel() {
            // Create floor
            const floorGeometry = new THREE.PlaneGeometry(100, 100);
            // Use a simple material instead of texture that might not load
            const floorMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x333333,
                roughness: 0.8 
            });
            const floor = new THREE.Mesh(floorGeometry, floorMaterial);
            floor.rotation.x = -Math.PI / 2;
            floor.receiveShadow = true;
            scene.add(floor);
            
            // Create arena walls
            createWall(100, 10, 2, 0, 5, -50);
            createWall(100, 10, 2, 0, 5, 50);
            createWall(2, 10, 100, -50, 5, 0);
            createWall(2, 10, 100, 50, 5, 0);
            
            // Create some obstacles for cover
            createWall(8, 5, 8, -20, 2.5, -20);
            createWall(8, 5, 8, 20, 2.5, 20);
            createWall(15, 3, 3, 0, 1.5, 0);
            createWall(5, 7, 5, 30, 3.5, -30);
            createWall(5, 7, 5, -30, 3.5, 30);
            
            // Add weapon pickups
            createWeaponPickup('shotgun', 15, -15);
            createWeaponPickup('rocketLauncher', -15, 15);
            
            // Add enemies
            createEnemy(-35, -35);
            createEnemy(35, 35);
            createEnemy(-35, 35);
            createEnemy(0, -35);
            
            // Add AI players based on UI settings
            const aiCount = parseInt(document.getElementById('ai-count').value) || 0;
            const aiDifficulty = document.getElementById('ai-difficulty').value || 'MEDIUM';
            
            // Create AI players at different positions
            const aiPositions = [
                [30, -30],
                [-30, 30],
                [30, 30],
                [-30, -30]
            ];
            
            for (let i = 0; i < aiCount; i++) {
                if (i < aiPositions.length) {
                    createAIPlayer(
                        aiPositions[i][0], 
                        aiPositions[i][1], 
                        aiDifficulty, 
                        `Bot-${i+1}`
                    );
                }
            }
            
            // Add skybox
            const skyboxGeometry = new THREE.BoxGeometry(1000, 1000, 1000);
            const skyboxMaterials = [
                new THREE.MeshBasicMaterial({ color: 0x000833, side: THREE.BackSide }),
                new THREE.MeshBasicMaterial({ color: 0x000833, side: THREE.BackSide }),
                new THREE.MeshBasicMaterial({ color: 0x000833, side: THREE.BackSide }),
                new THREE.MeshBasicMaterial({ color: 0x000833, side: THREE.BackSide }),
                new THREE.MeshBasicMaterial({ color: 0x000833, side: THREE.BackSide }),
                new THREE.MeshBasicMaterial({ color: 0x000833, side: THREE.BackSide })
            ];
            const skybox = new THREE.Mesh(skyboxGeometry, skyboxMaterials);
            scene.add(skybox);
            
            // Add some particles for atmosphere
            createParticles();
        }
        
        function createWall(width, height, depth, x, y, z) {
            const wallGeometry = new THREE.BoxGeometry(width, height, depth);
            // Use a simple material instead of texture that might not load
            const wallMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x555555,
                roughness: 0.7 
            });
            const wall = new THREE.Mesh(wallGeometry, wallMaterial);
            wall.position.set(x, y, z);
            wall.castShadow = true;
            wall.receiveShadow = true;
            scene.add(wall);
            
            // Add to obstacles array for collision detection
            obstacles.push({
                mesh: wall,
                width: width,
                height: height,
                depth: depth,
                x: x,
                y: y,
                z: z
            });
            
            return wall;
        }
        
        function createWeaponPickup(type, x, z) {
            const geometry = new THREE.BoxGeometry(0.8, 0.8, 1.5);
            
            let color;
            switch(type) {
                case 'shotgun':
                    color = 0xff0000;
                    break;
                case 'rocketLauncher':
                    color = 0x0000ff;
                    break;
                default:
                    color = 0x00ff00;
            }
            
            const material = new THREE.MeshStandardMaterial({ 
                color: color,
                emissive: color,
                emissiveIntensity: 0.5
            });
            
            const pickup = new THREE.Mesh(geometry, material);
            pickup.position.set(x, 0.8, z);
            pickup.userData = { type: 'weapon', weaponType: type };
            scene.add(pickup);
            
            pickups.push(pickup);
            
            return pickup;
        }
        
        function createEnemy(x, z) {
            // Randomly select enemy type
            const enemyType = enemyTypes[Math.floor(Math.random() * enemyTypes.length)];
            
            let geometry, material, health, speed, color, size;
            
            switch(enemyType) {
                case 'fast':
                    geometry = new THREE.CylinderGeometry(0.4, 0.4, 2, 8);
                    color = 0x00ff00;
                    health = 30;
                    speed = 0.06;
                    size = 0.8;
                    break;
                case 'tank':
                    geometry = new THREE.CylinderGeometry(0.7, 0.7, 2.5, 8);
                    color = 0x0000ff;
                    health = 100;
                    speed = 0.02;
                    size = 1.2;
                    break;
                default: // basic
                    geometry = new THREE.CylinderGeometry(0.5, 0.5, 2, 8);
                    color = 0xff0000;
                    health = 50;
                    speed = 0.03;
                    size = 1;
            }
            
            material = new THREE.MeshStandardMaterial({ color: color });
            const enemy = new THREE.Mesh(geometry, material);
            enemy.position.set(x, 1.5 * size, z);
            enemy.scale.set(size, size, size);
            
            enemy.userData = { 
                type: 'enemy',
                enemyType: enemyType,
                health: health,
                maxHealth: health,
                speed: speed,
                lastAttack: 0,
                scoreValue: enemyType === 'tank' ? 30 : (enemyType === 'fast' ? 20 : 10)
            };
            
            // Add health bar to enemy
            const healthBarGeometry = new THREE.PlaneGeometry(1, 0.1);
            const healthBarMaterial = new THREE.MeshBasicMaterial({ color: 0x333333 });
            const healthBar = new THREE.Mesh(healthBarGeometry, healthBarMaterial);
            healthBar.position.y = 2 * size;
            enemy.add(healthBar);
            
            const healthFillGeometry = new THREE.PlaneGeometry(1, 0.1);
            const healthFillMaterial = new THREE.MeshBasicMaterial({ color: 0x00ff00 });
            const healthFill = new THREE.Mesh(healthFillGeometry, healthFillMaterial);
            healthFill.position.z = 0.01;
            healthBar.add(healthFill);
            
            enemy.userData.healthFill = healthFill;
            
            scene.add(enemy);
            enemies.push(enemy);
            
            return enemy;
        }
        
        // Create an AI player that behaves more like a human player
        function createAIPlayer(x, z, difficulty = 'MEDIUM', name = '') {
            // Create a group to hold all AI player components
            const aiPlayer = new THREE.Group();
            
            // Create player body (more humanoid than basic enemies)
            const bodyGeometry = new THREE.CylinderGeometry(0.4, 0.4, 1.8, 8);
            const bodyMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x8844aa,
                roughness: 0.7
            });
            const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
            body.position.y = 0.9; // Center of body
            aiPlayer.add(body);
            
            // Create head
            const headGeometry = new THREE.SphereGeometry(0.3, 16, 16);
            const headMaterial = new THREE.MeshStandardMaterial({ 
                color: 0xffcc88,
                roughness: 0.5
            });
            const head = new THREE.Mesh(headGeometry, headMaterial);
            head.position.y = 1.9; // Top of body + head radius
            aiPlayer.add(head);
            
            // Create weapon holder (right arm)
            const armGeometry = new THREE.BoxGeometry(0.15, 0.15, 0.6);
            const armMaterial = new THREE.MeshStandardMaterial({ color: 0x8844aa });
            const arm = new THREE.Mesh(armGeometry, armMaterial);
            arm.position.set(0.4, 1.5, 0);
            arm.rotation.z = -Math.PI / 4; // Angle arm outward
            aiPlayer.add(arm);
            
            // Add weapon to arm
            const weaponGeometry = new THREE.BoxGeometry(0.1, 0.1, 0.5);
            const weaponMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x00ffff,
                emissive: 0x00ffff,
                emissiveIntensity: 0.5
            });
            const weapon = new THREE.Mesh(weaponGeometry, weaponMaterial);
            weapon.position.set(0, 0, -0.4); // Position at end of arm
            arm.add(weapon);
            
            // Set AI player position
            aiPlayer.position.set(x, 1.6, z); // Same height as player, exactly on ground
            
            // Add health bar
            const healthBarGeometry = new THREE.PlaneGeometry(1, 0.1);
            const healthBarMaterial = new THREE.MeshBasicMaterial({ color: 0x333333 });
            const healthBar = new THREE.Mesh(healthBarGeometry, healthBarMaterial);
            healthBar.position.y = 2.3; // Above head
            aiPlayer.add(healthBar);
            
            const healthFillGeometry = new THREE.PlaneGeometry(1, 0.1);
            const healthFillMaterial = new THREE.MeshBasicMaterial({ color: 0x00ffff });
            const healthFill = new THREE.Mesh(healthFillGeometry, healthFillMaterial);
            healthFill.position.z = 0.01;
            healthBar.add(healthFill);
            
            // Add name tag if provided
            if (name) {
                // Create a canvas for the name tag
                const canvas = document.createElement('canvas');
                const context = canvas.getContext('2d');
                canvas.width = 256;
                canvas.height = 64;
                context.font = 'Bold 32px Arial';
                context.fillStyle = 'white';
                context.textAlign = 'center';
                context.fillText(name, 128, 40);
                
                // Create texture from canvas
                const texture = new THREE.CanvasTexture(canvas);
                
                // Create name tag mesh
                const nameTagGeometry = new THREE.PlaneGeometry(1, 0.25);
                const nameTagMaterial = new THREE.MeshBasicMaterial({ 
                    map: texture,
                    transparent: true,
                    depthTest: false
                });
                const nameTag = new THREE.Mesh(nameTagGeometry, nameTagMaterial);
                nameTag.position.y = 2.5; // Above health bar
                nameTag.rotation.x = -0.2; // Tilt slightly for better visibility
                aiPlayer.add(nameTag);
            }
            
            // Store AI data
            aiPlayer.userData = {
                type: 'aiPlayer',
                health: 100,
                maxHealth: 100,
                speed: MOVE_SPEED * 0.8, // Slightly slower than player
                lastShotTime: 0,
                scoreValue: 50,
                difficulty: AI_DIFFICULTY[difficulty] || AI_DIFFICULTY.MEDIUM,
                name: name || `AI-${Math.floor(Math.random() * 1000)}`,
                
                // AI state
                targetPosition: new THREE.Vector3(),
                currentPath: [],
                pathIndex: 0,
                state: 'patrolling', // patrolling, chasing, attacking, retreating
                lastStateChange: performance.now(),
                lastDecisionTime: performance.now(),
                
                // Physics
                velocity: new THREE.Vector3(0, 0, 0),
                onGround: true,
                
                // Weapon system (similar to player)
                weapons: {
                    blaster: { 
                        name: "Basic Blaster", 
                        damage: 10, 
                        ammo: 100, 
                        maxAmmo: 100, 
                        fireRate: 5, 
                        active: true,
                        projectileColor: 0x00ffff,
                        projectileSize: 0.1,
                        projectileSpeed: 1.0,
                        projectileCount: 1
                    },
                    shotgun: { 
                        name: "Shotgun", 
                        damage: 15, 
                        ammo: 0, 
                        maxAmmo: 30, 
                        fireRate: 2, 
                        active: false,
                        projectileColor: 0xff9900,
                        projectileSize: 0.05,
                        projectileSpeed: 1.2,
                        projectileCount: 8,
                        spread: 0.2
                    },
                    rocketLauncher: { 
                        name: "Rocket Launcher", 
                        damage: 50, 
                        ammo: 0, 
                        maxAmmo: 10, 
                        fireRate: 1, 
                        active: false,
                        projectileColor: 0xff0000,
                        projectileSize: 0.2,
                        projectileSpeed: 0.8,
                        projectileCount: 1,
                        explosive: true,
                        explosionRadius: 3
                    }
                },
                
                // Helper functions
                getActiveWeapon: function() {
                    for (const type in this.weapons) {
                        if (this.weapons[type].active) {
                            return this.weapons[type];
                        }
                    }
                    return this.weapons.blaster;
                },
                
                switchWeapon: function(weaponType) {
                    // Only switch if we have ammo
                    if (weaponType !== 'blaster' && this.weapons[weaponType].ammo <= 0) {
                        return false;
                    }
                    
                    for (const type in this.weapons) {
                        this.weapons[type].active = false;
                    }
                    this.weapons[weaponType].active = true;
                    
                    // Update weapon model color
                    const weaponMesh = arm.children[0];
                    if (weaponMesh) {
                        switch(weaponType) {
                            case 'shotgun':
                                weaponMesh.material.color.set(0xff9900);
                                weaponMesh.material.emissive.set(0xff9900);
                                break;
                            case 'rocketLauncher':
                                weaponMesh.material.color.set(0xff0000);
                                weaponMesh.material.emissive.set(0xff0000);
                                break;
                            default: // blaster
                                weaponMesh.material.color.set(0x00ffff);
                                weaponMesh.material.emissive.set(0x00ffff);
                                break;
                        }
                    }
                    
                    return true;
                }
            };
            
            // Store references to body parts for animation
            aiPlayer.userData.head = head;
            aiPlayer.userData.body = body;
            aiPlayer.userData.arm = arm;
            aiPlayer.userData.weapon = weapon;
            aiPlayer.userData.healthFill = healthFill;
            
            // Add to scene and tracking array
            scene.add(aiPlayer);
            aiPlayers.push(aiPlayer);
            
            return aiPlayer;
        }
        
        function createParticles() {
            const particleCount = 500;
            const particles = new THREE.BufferGeometry();
            const positions = new Float32Array(particleCount * 3);
            
            for (let i = 0; i < particleCount * 3; i += 3) {
                positions[i] = (Math.random() - 0.5) * 100;
                positions[i + 1] = Math.random() * 50;
                positions[i + 2] = (Math.random() - 0.5) * 100;
            }
            
            particles.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            
            const particleMaterial = new THREE.PointsMaterial({
                color: 0x888888,
                size: 0.1,
                transparent: true,
                opacity: 0.5
            });
            
            const particleSystem = new THREE.Points(particles, particleMaterial);
            scene.add(particleSystem);
        }
        
        function setupEventListeners() {
            // Get the canvas element
            const canvas = document.getElementById('gameCanvas');
            
            // Setup pointer lock
            canvas.addEventListener('click', function() {
                if (!gameStarted) return;
                
                // Request pointer lock
                canvas.requestPointerLock = canvas.requestPointerLock || 
                                           canvas.mozRequestPointerLock ||
                                           canvas.webkitRequestPointerLock;
                canvas.requestPointerLock();
                
                // Shoot when clicking
                shoot();
            });
            
            // Pointer lock change event
            document.addEventListener('pointerlockchange', lockChangeAlert, false);
            document.addEventListener('mozpointerlockchange', lockChangeAlert, false);
            document.addEventListener('webkitpointerlockchange', lockChangeAlert, false);
            
            function lockChangeAlert() {
                if (document.pointerLockElement === canvas ||
                    document.mozPointerLockElement === canvas ||
                    document.webkitPointerLockElement === canvas) {
                    console.log('Pointer lock active');
                } else {
                    console.log('Pointer lock inactive');
                }
            }
            
            // Function to handle keydown events
            function handleKeyDown(event) {
                if (!gameStarted) {
                    console.log("Key pressed but game not started:", event.keyCode);
                    return;
                }
                
                console.log("Key down:", event.keyCode, "Key:", event.key);
                
                // Handle by keyCode first (for compatibility)
                switch (event.keyCode) {
                    case 87: // W
                        console.log("W key pressed");
                        moveForward = true;
                        break;
                    case 38: // Up arrow
                        console.log("Up arrow pressed");
                        moveForward = true;
                        break;
                    case 83: // S
                        console.log("S key pressed");
                        moveBackward = true;
                        break;
                    case 40: // Down arrow
                        console.log("Down arrow pressed");
                        moveBackward = true;
                        break;
                    case 65: // A
                        console.log("A key pressed");
                        moveLeft = true;
                        break;
                    case 37: // Left arrow
                        console.log("Left arrow pressed");
                        moveLeft = true;
                        break;
                    case 68: // D
                        console.log("D key pressed");
                        moveRight = true;
                        break;
                    case 39: // Right arrow
                        console.log("Right arrow pressed");
                        moveRight = true;
                        break;
                    case 49: // 1
                        switchWeapon('blaster');
                        break;
                    case 50: // 2
                        if (weapons.shotgun.ammo > 0) switchWeapon('shotgun');
                        break;
                    case 51: // 3
                        if (weapons.rocketLauncher.ammo > 0) switchWeapon('rocketLauncher');
                        break;
                    case 32: // Space
                        console.log("Space pressed");
                        if (canJump) {
                            jumping = true;
                            canJump = false;
                            velocity.y = JUMP_FORCE;
                        }
                        break;
                    case 192: // Backtick/tilde key
                    case 96: // Numpad 0 (alternative for backtick)
                    case 48: // 0 key (another alternative)
                        toggleDebugMode();
                        break;
                    default:
                        // Fallback to key property for browsers that don't support keyCode
                        handleKeyByName(event.key, true);
                        break;
                }
            }
            
            // Function to handle keyup events
            function handleKeyUp(event) {
                if (!gameStarted) return;
                
                switch (event.keyCode) {
                    case 87: // W
                        moveForward = false;
                        break;
                    case 38: // Up arrow
                        moveForward = false;
                        break;
                    case 83: // S
                        moveBackward = false;
                        break;
                    case 40: // Down arrow
                        moveBackward = false;
                        break;
                    case 65: // A
                        moveLeft = false;
                        break;
                    case 37: // Left arrow
                        moveLeft = false;
                        break;
                    case 68: // D
                        moveRight = false;
                        break;
                    case 39: // Right arrow
                        moveRight = false;
                        break;
                    case 32: // Space
                        // We don't reset jumping here as it's handled in the physics update
                        break;
                    default:
                        // Fallback to key property for browsers that don't support keyCode
                        handleKeyByName(event.key, false);
                        break;
                }
            }
            
            // Attach event listeners to both canvas and window
            canvas.addEventListener('keydown', handleKeyDown);
            canvas.addEventListener('keyup', handleKeyUp);
            
            // Also attach to window as a fallback
            window.addEventListener('keydown', handleKeyDown);
            window.addEventListener('keyup', handleKeyUp);
            
            // Helper function to handle keys by name
            function handleKeyByName(key, isDown) {
                switch(key.toLowerCase()) {
                    case 'w':
                    case 'arrowup':
                        console.log(isDown ? "W/Up key pressed" : "W/Up key released");
                        moveForward = isDown;
                        break;
                    case 's':
                    case 'arrowdown':
                        console.log(isDown ? "S/Down key pressed" : "S/Down key released");
                        moveBackward = isDown;
                        break;
                    case 'a':
                    case 'arrowleft':
                        console.log(isDown ? "A/Left key pressed" : "A/Left key released");
                        moveLeft = isDown;
                        break;
                    case 'd':
                    case 'arrowright':
                        console.log(isDown ? "D/Right key pressed" : "D/Right key released");
                        moveRight = isDown;
                        break;
                    case '1':
                        if (isDown) switchWeapon('blaster');
                        break;
                    case '2':
                        if (isDown && weapons.shotgun.ammo > 0) switchWeapon('shotgun');
                        break;
                    case '3':
                        if (isDown && weapons.rocketLauncher.ammo > 0) switchWeapon('rocketLauncher');
                        break;
                    case ' ':
                        if (isDown) shoot();
                        break;
                    case '`':
                    case '0':
                        if (isDown) toggleDebugMode();
                        break;
                }
            }
            
            // Mouse controls for aiming
            canvas.addEventListener('mousemove', function(event) {
                if (!gameStarted) return;
                
                // Calculate mouse movement delta
                const movementX = event.movementX || event.mozMovementX || event.webkitMovementX || 0;
                const movementY = event.movementY || event.mozMovementY || event.webkitMovementY || 0;
                
                // Update rotation based on mouse movement
                targetYaw -= movementX * mouseSensitivity;
                targetPitch -= movementY * mouseSensitivity;
                
                // Limit pitch to avoid flipping
                targetPitch = Math.max(-Math.PI/2, Math.min(Math.PI/2, targetPitch));
            });
            
            // Mouse click for shooting
            canvas.addEventListener('mousedown', function(event) {
                if (!gameStarted) return;
                
                console.log("Mouse down:", event.button);
                
                if (event.button === 0) { // Left click
                    mouseIsDown = true;
                    shoot();
                }
            });
            
            canvas.addEventListener('mouseup', function(event) {
                if (event.button === 0) {
                    mouseIsDown = false;
                }
            });
            
            // Handle window resize
            window.addEventListener('resize', function() {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            });
        }
        
        // Track mouse state
        let mouseIsDown = false;
        
        function switchWeapon(weaponType) {
            for (const type in weapons) {
                weapons[type].active = false;
            }
            weapons[weaponType].active = true;
            
            // Update visible weapon model
            updateWeaponModel(weaponType);
            
            updateHUD();
        }
        
        function updateWeaponModel(weaponType) {
            // Hide current weapon model if exists
            if (currentWeaponModel) {
                currentWeaponModel.visible = false;
            }
            
            // Show the selected weapon model
            currentWeaponModel = weaponModels[weaponType];
            if (currentWeaponModel) {
                currentWeaponModel.visible = true;
                
                // Add weapon switching animation
                animateWeaponSwitch(currentWeaponModel);
            }
        }
        
        function animateWeaponSwitch(weaponModel) {
            // Store original position
            const originalY = weaponModel.position.y;
            
            // Start from below view
            weaponModel.position.y = originalY - 0.5;
            weaponModel.rotation.x = 0.5;
            
            // Animate to normal position
            const startTime = performance.now();
            const duration = 300; // milliseconds
            
            function animateStep() {
                const now = performance.now();
                const elapsed = now - startTime;
                const progress = Math.min(elapsed / duration, 1);
                
                // Ease-out function
                const easeProgress = 1 - Math.pow(1 - progress, 3);
                
                // Update position and rotation
                weaponModel.position.y = originalY - 0.5 + (0.5 * easeProgress);
                weaponModel.rotation.x = 0.5 - (0.5 * easeProgress);
                
                if (progress < 1) {
                    requestAnimationFrame(animateStep);
                }
            }
            
            animateStep();
        }
        
        function createWeaponModels() {
            // Create a container for all weapon models
            const weaponContainer = new THREE.Object3D();
            
            // Position the weapon container in the bottom right of the view
            weaponContainer.position.set(0.3, -0.3, -0.5);
            camera.add(weaponContainer);
            
            // Create blaster model
            const blasterGeometry = new THREE.BoxGeometry(0.08, 0.08, 0.3);
            const blasterMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x00ffff,
                emissive: 0x00ffff,
                emissiveIntensity: 0.5
            });
            weaponModels.blaster = new THREE.Mesh(blasterGeometry, blasterMaterial);
            weaponModels.blaster.position.set(0, 0, 0);
            weaponContainer.add(weaponModels.blaster);
            
            // Create shotgun model
            const shotgunGeometry = new THREE.BoxGeometry(0.1, 0.08, 0.25);
            const shotgunBarrelGeometry = new THREE.CylinderGeometry(0.02, 0.02, 0.3, 8);
            const shotgunMaterial = new THREE.MeshStandardMaterial({ 
                color: 0xff9900,
                emissive: 0xff9900,
                emissiveIntensity: 0.5
            });
            
            weaponModels.shotgun = new THREE.Group();
            
            const shotgunBody = new THREE.Mesh(shotgunGeometry, shotgunMaterial);
            weaponModels.shotgun.add(shotgunBody);
            
            const shotgunBarrel = new THREE.Mesh(shotgunBarrelGeometry, shotgunMaterial);
            shotgunBarrel.rotation.x = Math.PI / 2;
            shotgunBarrel.position.set(0, 0, -0.15);
            weaponModels.shotgun.add(shotgunBarrel);
            
            weaponModels.shotgun.position.set(0, 0, 0);
            weaponModels.shotgun.visible = false;
            weaponContainer.add(weaponModels.shotgun);
            
            // Create rocket launcher model
            const rocketLauncherGeometry = new THREE.CylinderGeometry(0.05, 0.05, 0.4, 8);
            const rocketLauncherMaterial = new THREE.MeshStandardMaterial({ 
                color: 0xff0000,
                emissive: 0xff0000,
                emissiveIntensity: 0.5
            });
            
            weaponModels.rocketLauncher = new THREE.Group();
            
            const rocketLauncherBody = new THREE.Mesh(rocketLauncherGeometry, rocketLauncherMaterial);
            rocketLauncherBody.rotation.x = Math.PI / 2;
            weaponModels.rocketLauncher.add(rocketLauncherBody);
            
            const rocketLauncherSight = new THREE.Mesh(
                new THREE.BoxGeometry(0.03, 0.03, 0.1),
                rocketLauncherMaterial
            );
            rocketLauncherSight.position.set(0, 0.07, 0);
            weaponModels.rocketLauncher.add(rocketLauncherSight);
            
            weaponModels.rocketLauncher.position.set(0, 0, 0);
            weaponModels.rocketLauncher.visible = false;
            weaponContainer.add(weaponModels.rocketLauncher);
            
            // Set initial weapon model
            updateWeaponModel('blaster');
        }
        
        function getActiveWeapon() {
            for (const type in weapons) {
                if (weapons[type].active) {
                    return weapons[type];
                }
            }
            return weapons.blaster;
        }
        
        function shoot() {
            const weapon = getActiveWeapon();
            const now = performance.now();
            
            // Check fire rate and ammo
            if (now - lastShotTime < 1000 / weapon.fireRate || (weapon.name !== "Basic Blaster" && weapon.ammo <= 0)) {
                return;
            }
            
            lastShotTime = now;
            
            // Reduce ammo (except for blaster which has infinite ammo)
            if (weapon.name !== "Basic Blaster") {
                weapon.ammo--;
            }
            
            // Create projectiles based on weapon type
            for (let i = 0; i < weapon.projectileCount; i++) {
                // Create projectile
                const projectileGeometry = new THREE.SphereGeometry(weapon.projectileSize, 8, 8);
                const projectileMaterial = new THREE.MeshBasicMaterial({ color: weapon.projectileColor });
                const projectile = new THREE.Mesh(projectileGeometry, projectileMaterial);
                
                // Position at camera position
                projectile.position.copy(camera.position);
                projectile.position.add(yawObject.position);
                
                // Calculate shooting direction based on camera view
                // Create a vector pointing forward in camera space
                const direction = new THREE.Vector3();
                camera.getWorldDirection(direction);
                direction.normalize();
                
                // Add spread for shotgun
                if (weapon.spread) {
                    const spread = weapon.spread;
                    direction.x += (Math.random() - 0.5) * spread;
                    direction.y += (Math.random() - 0.5) * spread;
                    direction.z += (Math.random() - 0.5) * spread;
                    direction.normalize();
                }
                
                // Store projectile data
                projectile.userData = {
                    type: 'projectile',
                    direction: direction,
                    speed: weapon.projectileSpeed,
                    damage: weapon.damage,
                    timeCreated: now,
                    explosive: weapon.explosive || false,
                    explosionRadius: weapon.explosionRadius || 0,
                    source: 'player'
                };
                
                // Add to scene and tracking array
                scene.add(projectile);
                projectiles.push(projectile);
                
                // Add tracer line for debug mode
                if (debugMode) {
                    const tracerGeometry = new THREE.BufferGeometry();
                    const tracerMaterial = new THREE.LineBasicMaterial({ 
                        color: weapon.projectileColor,
                        transparent: true,
                        opacity: 0.5
                    });
                    
                    // Create a line showing the projectile's path
                    const startPoint = projectile.position.clone();
                    const endPoint = startPoint.clone().add(
                        direction.clone().multiplyScalar(50) // Show 50 units ahead
                    );
                    
                    const points = [startPoint, endPoint];
                    tracerGeometry.setFromPoints(points);
                    
                    const tracer = new THREE.Line(tracerGeometry, tracerMaterial);
                    tracer.userData = { type: 'tracer', timeCreated: now };
                    scene.add(tracer);
                    
                    // Store tracer reference in projectile for cleanup
                    projectile.userData.tracer = tracer;
                }
            }
            
            // Add muzzle flash effect
            createMuzzleFlash();
            
            // Update HUD
            updateHUD();
        }
        
        function createMuzzleFlash() {
            // Create a point light for muzzle flash
            const muzzleLight = new THREE.PointLight(0xffff00, 5, 3);
            
            // Position the light at the end of the current weapon
            if (currentWeaponModel) {
                // Get the weapon type
                const weaponType = getActiveWeaponType();
                
                // Set position based on weapon type
                if (weaponType === 'blaster') {
                    muzzleLight.position.set(0.3, -0.3, -0.8);
                } else if (weaponType === 'shotgun') {
                    muzzleLight.position.set(0.3, -0.3, -0.9);
                } else if (weaponType === 'rocketLauncher') {
                    muzzleLight.position.set(0.3, -0.3, -0.9);
                }
            } else {
                muzzleLight.position.copy(camera.position);
            }
            
            // Add to camera
            camera.add(muzzleLight);
            
            // Remove the light after a short delay
            setTimeout(() => {
                camera.remove(muzzleLight);
            }, 50);
            
            // Also add a visual flash effect
            const flashGeometry = new THREE.SphereGeometry(0.05, 8, 8);
            const flashMaterial = new THREE.MeshBasicMaterial({ 
                color: 0xffff00,
                transparent: true,
                opacity: 0.8
            });
            const flashMesh = new THREE.Mesh(flashGeometry, flashMaterial);
            
            // Position at the end of the weapon
            if (currentWeaponModel) {
                const weaponType = getActiveWeaponType();
                
                if (weaponType === 'blaster') {
                    flashMesh.position.set(0.3, -0.3, -0.8);
                } else if (weaponType === 'shotgun') {
                    flashMesh.position.set(0.3, -0.3, -0.9);
                } else if (weaponType === 'rocketLauncher') {
                    flashMesh.position.set(0.3, -0.3, -0.9);
                }
            }
            
            camera.add(flashMesh);
            
            // Animate and remove the flash
            setTimeout(() => {
                camera.remove(flashMesh);
            }, 50);
        }
        
        // Helper function to get the active weapon type
        function getActiveWeaponType() {
            for (const type in weapons) {
                if (weapons[type].active) {
                    return type;
                }
            }
            return 'blaster';
        }
        
        function updateHUD() {
            const weapon = getActiveWeapon();
            document.getElementById('weapon-info').textContent = `Current Weapon: ${weapon.name}`;
            document.getElementById('ammo').textContent = `Ammo: ${weapon.name === "Basic Blaster" ? "" : weapon.ammo}`;
            document.getElementById('health-fill').style.width = `${health}%`;
            document.getElementById('score').textContent = `Score: ${score}`;
            
            // Update debug mode indicator
            if (debugMode) {
                if (!document.getElementById('debug-indicator')) {
                    const debugIndicator = document.createElement('div');
                    debugIndicator.id = 'debug-indicator';
                    debugIndicator.style.position = 'absolute';
                    debugIndicator.style.top = '50px';
                    debugIndicator.style.left = '50%';
                    debugIndicator.style.transform = 'translateX(-50%)';
                    debugIndicator.style.color = 'lime';
                    debugIndicator.style.backgroundColor = 'rgba(0,0,0,0.7)';
                    debugIndicator.style.padding = '10px 15px';
                    debugIndicator.style.borderRadius = '5px';
                    debugIndicator.style.fontWeight = 'bold';
                    debugIndicator.style.zIndex = '100';
                    debugIndicator.style.border = '2px solid lime';
                    debugIndicator.innerHTML = 'DEBUG MODE<br><span style="font-size: 12px; font-weight: normal;">Red line shows shooting direction<br>Press 0 or ` (backtick) to toggle</span>';
                    document.body.appendChild(debugIndicator);
                }
            } else {
                const debugIndicator = document.getElementById('debug-indicator');
                if (debugIndicator) {
                    document.body.removeChild(debugIndicator);
                }
            }
        }
        
        function checkPickupCollisions() {
            for (let i = pickups.length - 1; i >= 0; i--) {
                const pickup = pickups[i];
                const distance = pickup.position.distanceTo(yawObject.position);
                
                if (distance < 2) {
                    if (pickup.userData.type === 'weapon') {
                        // Add ammo for weapon
                        const weaponType = pickup.userData.weaponType;
                        weapons[weaponType].ammo = weapons[weaponType].maxAmmo;
                        
                        // Switch to the weapon
                        switchWeapon(weaponType);
                        
                        // Show pickup info
                        const pickupInfo = document.getElementById('pickup-info');
                        pickupInfo.textContent = `Picked up: ${weapons[weaponType].name}`;
                        setTimeout(() => {
                            pickupInfo.textContent = '';
                        }, 2000);
                        
                        // Remove pickup
                        scene.remove(pickup);
                        pickups.splice(i, 1);
                        
                        // Respawn pickup after delay
                        setTimeout(() => {
                            const newPickup = createWeaponPickup(
                                weaponType, 
                                pickup.position.x, 
                                pickup.position.z
                            );
                        }, 10000);
                    }
                }
            }
        }
        
        function updateEnemies() {
            for (let i = enemies.length - 1; i >= 0; i--) {
                const enemy = enemies[i];
                
                // Move towards player
                const directionToPlayer = new THREE.Vector3();
                directionToPlayer.subVectors(yawObject.position, enemy.position);
                directionToPlayer.y = 0; // Keep on same y level
                directionToPlayer.normalize();
                
                enemy.position.add(directionToPlayer.multiplyScalar(enemy.userData.speed));
                
                // Look at player
                enemy.lookAt(yawObject.position);
                
                // Update enemy health bar
                if (enemy.userData.healthFill) {
                    const healthPercent = enemy.userData.health / enemy.userData.maxHealth;
                    enemy.userData.healthFill.scale.x = healthPercent;
                    enemy.userData.healthFill.position.x = (healthPercent - 1) / 2;
                    
                    // Change color based on health
                    if (healthPercent < 0.3) {
                        enemy.userData.healthFill.material.color.set(0xff0000);
                    } else if (healthPercent < 0.6) {
                        enemy.userData.healthFill.material.color.set(0xffff00);
                    } else {
                        enemy.userData.healthFill.material.color.set(0x00ff00);
                    }
                }
                
                // Make health bar face camera
                if (enemy.children.length > 0) {
                    enemy.children[0].lookAt(camera.position);
                }
                
                // Check if enemy can attack player
                const distanceToPlayer = enemy.position.distanceTo(yawObject.position);
                const now = performance.now();
                
                // Different attack behaviors based on enemy type
                let attackDistance = 2;
                let attackDamage = 10;
                let attackCooldown = 1000;
                
                switch(enemy.userData.enemyType) {
                    case 'fast':
                        attackDistance = 1.5;
                        attackDamage = 5;
                        attackCooldown = 500;
                        break;
                    case 'tank':
                        attackDistance = 2.5;
                        attackDamage = 20;
                        attackCooldown = 2000;
                        break;
                }
                
                if (distanceToPlayer < attackDistance && now - enemy.userData.lastAttack > attackCooldown) {
                    enemy.userData.lastAttack = now;
                    health -= attackDamage;
                    
                    // Visual feedback for taking damage
                    document.body.style.backgroundColor = "rgba(255,0,0,0.3)";
                    setTimeout(() => {
                        document.body.style.backgroundColor = "";
                    }, 100);
                    
                    // Update health bar
                    updateHUD();
                    
                    // Game over check
                    if (health <= 0) {
                        gameOver();
                    }
                }
                
                // Check for projectile hits
                for (let j = projectiles.length - 1; j >= 0; j--) {
                    const projectile = projectiles[j];
                    const distance = projectile.position.distanceTo(enemy.position);
                    
                    // Increase collision detection radius based on enemy size
                    const hitRadius = enemy.scale.x + 0.5;
                    
                    // Visualize hit radius in debug mode
                    if (debugMode && !enemy.userData.hitRadiusVisualizer) {
                        const hitRadiusGeometry = new THREE.SphereGeometry(hitRadius, 16, 16);
                        const hitRadiusMaterial = new THREE.MeshBasicMaterial({
                            color: 0xff0000,
                            transparent: true,
                            opacity: 0.2,
                            wireframe: true
                        });
                        const hitRadiusVisualizer = new THREE.Mesh(hitRadiusGeometry, hitRadiusMaterial);
                        enemy.add(hitRadiusVisualizer);
                        enemy.userData.hitRadiusVisualizer = hitRadiusVisualizer;
                    } else if (!debugMode && enemy.userData.hitRadiusVisualizer) {
                        enemy.remove(enemy.userData.hitRadiusVisualizer);
                        enemy.userData.hitRadiusVisualizer = null;
                    }
                    
                    if (distance < hitRadius) {
                        // Hit an enemy
                        enemy.userData.health -= projectile.userData.damage;
                        
                        // Visual feedback for hit
                        enemy.material.emissive = new THREE.Color(0xff0000);
                        setTimeout(() => {
                            enemy.material.emissive = new THREE.Color(0x000000);
                        }, 100);
                        
                        // Create hit effect
                        createHitEffect(projectile.position);
                        
                        // Handle explosive projectiles
                        if (projectile.userData.explosive) {
                            createExplosion(projectile.position, projectile.userData.explosionRadius, projectile.userData.damage);
                        }
                        
                        // Remove tracer if exists
                        if (projectile.userData.tracer) {
                            scene.remove(projectile.userData.tracer);
                        }
                        
                        // Remove projectile
                        scene.remove(projectile);
                        projectiles.splice(j, 1);
                        
                        // Check if enemy is defeated
                        if (enemy.userData.health <= 0) {
                            // Add score
                            score += enemy.userData.scoreValue;
                            updateHUD();
                            
                            // Create score popup
                            createScorePopup(enemy.position, enemy.userData.scoreValue);
                            
                            // Remove enemy
                            scene.remove(enemy);
                            enemies.splice(i, 1);
                            
                            // Respawn enemy after delay
                            setTimeout(() => {
                                createEnemy(
                                    (Math.random() - 0.5) * 80,
                                    (Math.random() - 0.5) * 80
                                );
                            }, 5000);
                            
                            break; // Break the projectile loop since enemy is removed
                        }
                    }
                }
            }
        }
        
        function createExplosion(position, radius, damage) {
            // Visual explosion effect
            const explosionGeometry = new THREE.SphereGeometry(radius, 16, 16);
            const explosionMaterial = new THREE.MeshBasicMaterial({ 
                color: 0xff9900, 
                transparent: true, 
                opacity: 0.7 
            });
            const explosion = new THREE.Mesh(explosionGeometry, explosionMaterial);
            explosion.position.copy(position);
            scene.add(explosion);
            
            // Add explosion light
            const explosionLight = new THREE.PointLight(0xff5500, 5, radius * 2);
            explosionLight.position.copy(position);
            scene.add(explosionLight);
            
            // Damage enemies in radius
            for (let i = 0; i < enemies.length; i++) {
                const enemy = enemies[i];
                const distance = enemy.position.distanceTo(position);
                
                if (distance <= radius) {
                    // Calculate damage based on distance (more damage closer to center)
                    const damageMultiplier = 1 - (distance / radius);
                    const explosionDamage = damage * damageMultiplier;
                    enemy.userData.health -= explosionDamage;
                    
                    // Check if enemy is defeated
                    if (enemy.userData.health <= 0) {
                        scene.remove(enemy);
                        enemies.splice(i, 1);
                        i--; // Adjust index since we removed an element
                        
                        // Respawn enemy after delay
                        setTimeout(() => {
                            createEnemy(
                                (Math.random() - 0.5) * 80,
                                (Math.random() - 0.5) * 80
                            );
                        }, 5000);
                    }
                }
            }
            
            // Check if player is in explosion radius
            const distanceToPlayer = yawObject.position.distanceTo(position);
            if (distanceToPlayer <= radius) {
                const damageMultiplier = 1 - (distanceToPlayer / radius);
                const explosionDamage = damage * 0.5 * damageMultiplier; // Reduced self-damage
                health -= explosionDamage;
                updateHUD();
                
                // Game over check
                if (health <= 0) {
                    health = 100;
                    yawObject.position.set(-10, 1.6, -10);
                    updateHUD();
                }
            }
            
            // Fade out and remove explosion
            let opacity = 0.7;
            const fadeInterval = setInterval(() => {
                opacity -= 0.05;
                explosionMaterial.opacity = opacity;
                explosionLight.intensity = opacity * 5;
                
                if (opacity <= 0) {
                    clearInterval(fadeInterval);
                    scene.remove(explosion);
                    scene.remove(explosionLight);
                }
            }, 50);
        }
        
        function createScorePopup(position, value) {
            // Create a div for the score popup
            const scoreDiv = document.createElement('div');
            scoreDiv.textContent = '+' + value;
            scoreDiv.style.position = 'absolute';
            scoreDiv.style.color = '#ffff00';
            scoreDiv.style.fontSize = '24px';
            scoreDiv.style.fontWeight = 'bold';
            scoreDiv.style.textShadow = '0 0 5px #000';
            scoreDiv.style.pointerEvents = 'none';
            
            // Convert 3D position to screen position
            const vector = new THREE.Vector3();
            vector.copy(position);
            vector.y += 2; // Position above enemy
            
            // Project position to screen coordinates
            vector.project(camera);
            
            // Convert to CSS coordinates
            const x = (vector.x * 0.5 + 0.5) * window.innerWidth;
            const y = (-vector.y * 0.5 + 0.5) * window.innerHeight;
            
            scoreDiv.style.left = x + 'px';
            scoreDiv.style.top = y + 'px';
            
            document.body.appendChild(scoreDiv);
            
            // Animate and remove
            let opacity = 1;
            let posY = y;
            
            const animateInterval = setInterval(() => {
                opacity -= 0.05;
                posY -= 2;
                
                scoreDiv.style.opacity = opacity;
                scoreDiv.style.top = posY + 'px';
                
                if (opacity <= 0) {
                    clearInterval(animateInterval);
                    document.body.removeChild(scoreDiv);
                }
            }, 50);
        }
        
        function updateProjectiles() {
            const now = performance.now();
            
            for (let i = projectiles.length - 1; i >= 0; i--) {
                const projectile = projectiles[i];
                
                // Move projectile
                const moveVector = projectile.userData.direction.clone();
                moveVector.multiplyScalar(projectile.userData.speed);
                projectile.position.add(moveVector);
                
                // Check for wall collisions
                if (projectile.position.x < -49 || projectile.position.x > 49 ||
                    projectile.position.z < -49 || projectile.position.z > 49) {
                    
                    // Handle explosive projectiles
                    if (projectile.userData.explosive) {
                        createExplosion(projectile.position, projectile.userData.explosionRadius, projectile.userData.damage);
                    }
                    
                    // Remove tracer if exists
                    if (projectile.userData.tracer) {
                        scene.remove(projectile.userData.tracer);
                    }
                    
                    scene.remove(projectile);
                    projectiles.splice(i, 1);
                    continue;
                }
                
                // Check for AI projectiles hitting player
                if (projectile.userData.source === 'ai') {
                    const distanceToPlayer = projectile.position.distanceTo(yawObject.position);
                    const hitRadius = 0.5; // Player hit radius
                    
                    if (distanceToPlayer < hitRadius) {
                        // Player hit by AI projectile
                        health -= projectile.userData.damage;
                        
                        // Visual feedback for taking damage
                        document.body.style.backgroundColor = "rgba(255,0,0,0.3)";
                        setTimeout(() => {
                            document.body.style.backgroundColor = "";
                        }, 100);
                        
                        // Create hit effect
                        createHitEffect(projectile.position);
                        
                        // Handle explosive projectiles
                        if (projectile.userData.explosive) {
                            createExplosion(projectile.position, projectile.userData.explosionRadius, projectile.userData.damage);
                        }
                        
                        // Remove tracer if exists
                        if (projectile.userData.tracer) {
                            scene.remove(projectile.userData.tracer);
                        }
                        
                        // Remove projectile
                        scene.remove(projectile);
                        projectiles.splice(i, 1);
                        
                        // Update health bar
                        updateHUD();
                        
                        // Game over check
                        if (health <= 0) {
                            gameOver();
                        }
                        
                        continue;
                    }
                }
                
                // Remove projectiles after 5 seconds or if they go too far
                if (now - projectile.userData.timeCreated > 5000 || 
                    projectile.position.length() > 200) {
                    
                    // Remove tracer if exists
                    if (projectile.userData.tracer) {
                        scene.remove(projectile.userData.tracer);
                    }
                    
                    scene.remove(projectile);
                    projectiles.splice(i, 1);
                }
            }
        }
        
        function animatePickups() {
            const time = performance.now() * 0.001;
            
            pickups.forEach(pickup => {
                pickup.position.y = 0.8 + Math.sin(time * 2) * 0.2;
                pickup.rotation.y = time;
            });
        }
        
        function updatePlayerMovement(delta) {
            if (!gameStarted) return;
            
            // Apply gravity
            velocity.y -= GRAVITY;
            
            // Update player position based on velocity
            yawObject.position.y += velocity.y;
            
            // Check if player is on the ground
            if (yawObject.position.y < 1.6) { // Player height
                velocity.y = 0;
                yawObject.position.y = 1.6;
                canJump = true;
                jumping = false;
            }
            
            // Reset velocity
            velocity.x = 0;
            velocity.z = 0;
            
            // Set movement velocity based on key states
            if (moveForward) velocity.z -= MOVE_SPEED;
            if (moveBackward) velocity.z += MOVE_SPEED;
            if (moveLeft) velocity.x -= MOVE_SPEED;
            if (moveRight) velocity.x += MOVE_SPEED;
            
            // Normalize diagonal movement
            if (velocity.x !== 0 && velocity.z !== 0) {
                velocity.x *= 0.7071; // 1 / sqrt(2)
                velocity.z *= 0.7071;
            }
            
            // Rotate velocity based on camera rotation
            const rotatedVelocity = new THREE.Vector3(velocity.x, 0, velocity.z);
            rotatedVelocity.applyAxisAngle(new THREE.Vector3(0, 1, 0), yawObject.rotation.y);
            
            // Store current position for collision detection
            const oldPosition = {
                x: yawObject.position.x,
                y: yawObject.position.y,
                z: yawObject.position.z
            };
            
            // Apply velocity to position
            yawObject.position.x += rotatedVelocity.x;
            yawObject.position.z += rotatedVelocity.z;
            
            // Check for collisions with obstacles
            if (checkObstacleCollisions()) {
                // First, try just X movement
                yawObject.position.set(yawObject.position.x, oldPosition.y, oldPosition.z);
                if (checkObstacleCollisions()) {
                    // X movement caused collision, revert X
                    yawObject.position.x = oldPosition.x;
                }
                
                // Then, try just Z movement
                yawObject.position.set(yawObject.position.x, oldPosition.y, oldPosition.z);
                if (checkObstacleCollisions()) {
                    // Z movement caused collision, revert Z
                    yawObject.position.z = oldPosition.z;
                }
                
                // If we're still colliding, revert to old position completely
                if (checkObstacleCollisions()) {
                    yawObject.position.set(oldPosition.x, oldPosition.y, oldPosition.z);
                }
            }
            
            // Simple boundary checks
            if (yawObject.position.x < -48) yawObject.position.x = -48;
            if (yawObject.position.x > 48) yawObject.position.x = 48;
            if (yawObject.position.z < -48) yawObject.position.z = -48;
            if (yawObject.position.z > 48) yawObject.position.z = 48;
        }
        
        function checkObstacleCollisions() {
            // Player collision radius - make it smaller for more forgiving collisions
            const playerRadius = 0.2; // Reduced from 0.3
            const playerPos = yawObject.position;
            
            // Debug collision checks
            let collisionDetected = false;
            let collidedWith = null;
            
            // Check each obstacle
            for (let i = 0; i < obstacles.length; i++) {
                const obstacle = obstacles[i];
                
                // Simple box-sphere collision detection
                // Calculate closest point on box to player
                const closestX = Math.max(obstacle.x - obstacle.width/2, Math.min(playerPos.x, obstacle.x + obstacle.width/2));
                const closestY = Math.max(obstacle.y - obstacle.height/2, Math.min(playerPos.y, obstacle.y + obstacle.height/2));
                const closestZ = Math.max(obstacle.z - obstacle.depth/2, Math.min(playerPos.z, obstacle.z + obstacle.depth/2));
                
                // Calculate distance from closest point to player center
                const distanceX = closestX - playerPos.x;
                const distanceY = closestY - playerPos.y;
                const distanceZ = closestZ - playerPos.z;
                
                const distanceSquared = distanceX * distanceX + distanceY * distanceY + distanceZ * distanceZ;
                
                // Check if distance is less than player radius
                if (distanceSquared < playerRadius * playerRadius) {
                    console.log("Collision detected with obstacle:", obstacle);
                    collisionDetected = true;
                    collidedWith = obstacle;
                    break; // Exit loop on first collision
                }
            }
            
            // Only log when a collision is detected
            if (collisionDetected && collidedWith) {
                console.log("Collision detected! Player position:", playerPos, "Obstacle:", collidedWith);
            }
            
            return collisionDetected;
        }
        
        function animate() {
            if (!gameStarted) return;
            
            frameId = requestAnimationFrame(animate);
            
            const time = performance.now() / 1000;
            const delta = (time - prevTime) * 1000;
            prevTime = time;
            
            // Smoothly interpolate camera rotation to target rotation
            currentYaw += (targetYaw - currentYaw) * 0.2;
            currentPitch += (targetPitch - currentPitch) * 0.2;
            
            // Apply rotation to camera
            yawObject.rotation.y = currentYaw;
            pitchObject.rotation.x = currentPitch;
            
            // Add slight weapon sway based on movement
            if (currentWeaponModel) {
                currentWeaponModel.rotation.x = Math.sin(performance.now() * 0.002) * 0.05;
                currentWeaponModel.rotation.y = Math.cos(performance.now() * 0.001) * 0.05;
            }
            
            // Update debug direction indicator
            updateDebugDirectionIndicator();
            
            // Update player movement
            updatePlayerMovement(delta);
            
            // Update enemy positions
            updateEnemies();
            
            // Update AI players
            updateAIPlayers(delta);
            
            // Update projectiles
            updateProjectiles();
            
            // Check for pickups
            checkPickupCollisions();
            
            // Auto-shoot if holding mouse button
            if (mouseIsDown) {
                shoot();
            }
            
            // Update position display
            updatePositionDisplay();
            
            // Update debug info if enabled
            if (debugMode) {
                updateDebugInfo();
            }
            
            // Animate pickups
            animatePickups();
            
            // Render the scene
            renderer.render(scene, camera);
        }
        
        // Function to update AI players
        function updateAIPlayers(delta) {
            for (let i = aiPlayers.length - 1; i >= 0; i--) {
                const aiPlayer = aiPlayers[i];
                const userData = aiPlayer.userData;
                const now = performance.now();
                
                // Update health bar
                if (userData.healthFill) {
                    const healthPercent = userData.health / userData.maxHealth;
                    userData.healthFill.scale.x = healthPercent;
                    userData.healthFill.position.x = (healthPercent - 1) / 2;
                    
                    // Change color based on health
                    if (healthPercent < 0.3) {
                        userData.healthFill.material.color.set(0xff0000);
                    } else if (healthPercent < 0.6) {
                        userData.healthFill.material.color.set(0xffff00);
                    } else {
                        userData.healthFill.material.color.set(0x00ffff);
                    }
                }
                
                // Make health bar and name tag face camera
                for (let j = 0; j < aiPlayer.children.length; j++) {
                    const child = aiPlayer.children[j];
                    if (child.type === 'Mesh' && (child.material.map || child.children.length > 0)) {
                        child.lookAt(camera.position);
                    }
                }
                
                // AI decision making - change state based on conditions
                if (now - userData.lastDecisionTime > userData.difficulty.reactionTime) {
                    userData.lastDecisionTime = now;
                    
                    // Calculate distance to player
                    const distanceToPlayer = aiPlayer.position.distanceTo(yawObject.position);
                    
                    // Check if AI can see player (simple line of sight check)
                    const canSeePlayer = checkLineOfSight(aiPlayer.position, yawObject.position);
                    
                    // Decide what to do based on state, distance, and line of sight
                    if (canSeePlayer) {
                        if (distanceToPlayer < 10) {
                            // Close range - attack or retreat based on health
                            if (userData.health < 30) {
                                userData.state = 'retreating';
                            } else {
                                userData.state = 'attacking';
                                
                                // Choose appropriate weapon based on distance
                                if (distanceToPlayer < 5 && userData.weapons.shotgun.ammo > 0) {
                                    userData.switchWeapon('shotgun');
                                } else if (distanceToPlayer > 15 && userData.weapons.rocketLauncher.ammo > 0) {
                                    userData.switchWeapon('rocketLauncher');
                                } else {
                                    userData.switchWeapon('blaster');
                                }
                            }
                        } else if (distanceToPlayer < 30) {
                            // Medium range - chase player
                            userData.state = 'chasing';
                        } else {
                            // Far away - patrol or look for pickups
                            userData.state = 'patrolling';
                        }
                    } else {
                        // Can't see player - patrol or look for pickups
                        userData.state = 'patrolling';
                        
                        // Occasionally change patrol target
                        if (Math.random() < 0.3) {
                            setRandomPatrolTarget(aiPlayer);
                        }
                    }
                    
                    // Debug state display
                    if (debugMode) {
                        console.log(`AI ${userData.name} state: ${userData.state}, distance: ${distanceToPlayer.toFixed(2)}, can see player: ${canSeePlayer}`);
                    }
                }
                
                // Execute behavior based on current state
                switch (userData.state) {
                    case 'patrolling':
                        // Move toward patrol target
                        if (!userData.targetPosition.x && !userData.targetPosition.z) {
                            setRandomPatrolTarget(aiPlayer);
                        }
                        moveAIToTarget(aiPlayer, userData.targetPosition, delta);
                        
                        // Look for pickups
                        checkAIPickupCollisions(aiPlayer);
                        break;
                        
                    case 'chasing':
                        // Move toward player
                        moveAIToTarget(aiPlayer, yawObject.position, delta);
                        
                        // Look for pickups along the way
                        checkAIPickupCollisions(aiPlayer);
                        
                        // Shoot occasionally while chasing
                        if (Math.random() < 0.05 && checkLineOfSight(aiPlayer.position, yawObject.position)) {
                            aiShoot(aiPlayer, yawObject.position);
                        }
                        break;
                        
                    case 'attacking':
                        // Face player
                        const directionToPlayer = new THREE.Vector3();
                        directionToPlayer.subVectors(yawObject.position, aiPlayer.position);
                        directionToPlayer.y = 0; // Keep on same y level
                        
                        // Look at player (smooth rotation)
                        const targetRotation = Math.atan2(directionToPlayer.x, directionToPlayer.z);
                        aiPlayer.rotation.y = targetRotation;
                        
                        // Aim weapon at player (adjust arm and head)
                        if (userData.arm) {
                            // Calculate vertical angle to player
                            const verticalAngle = Math.atan2(directionToPlayer.y, 
                                Math.sqrt(directionToPlayer.x * directionToPlayer.x + directionToPlayer.z * directionToPlayer.z));
                            
                            // Rotate arm to aim at player
                            userData.arm.rotation.x = verticalAngle;
                        }
                        
                        // Shoot at player if we have line of sight
                        if (checkLineOfSight(aiPlayer.position, yawObject.position)) {
                            // Add slight randomness to target position based on difficulty
                            const targetPos = yawObject.position.clone();
                            const accuracy = userData.difficulty.accuracy;
                            
                            // Add head bobbing for more realistic targeting
                            targetPos.y += Math.sin(now * 0.003) * 0.1;
                            
                            // Shoot at player
                            aiShoot(aiPlayer, targetPos);
                        }
                        
                        // Occasionally strafe to avoid being an easy target
                        if (Math.random() < 0.1) {
                            // Strafe perpendicular to player direction
                            const strafeDir = new THREE.Vector3(-directionToPlayer.z, 0, directionToPlayer.x);
                            strafeDir.normalize();
                            
                            // Randomly choose left or right
                            if (Math.random() < 0.5) {
                                strafeDir.multiplyScalar(-1);
                            }
                            
                            // Store current position for collision detection
                            const oldStrafePosition = aiPlayer.position.clone();
                            
                            // Apply strafe movement with proper delta time scaling
                            const strafeDeltaSeconds = delta / 1000;
                            const strafeSpeed = MOVE_SPEED * 3.0; // Faster strafing for better evasion
                            const strafeMoveX = strafeDir.x * strafeSpeed * strafeDeltaSeconds;
                            const strafeMoveZ = strafeDir.z * strafeSpeed * strafeDeltaSeconds;
                            
                            // Apply movement with minimum threshold
                            const minStrafeMove = 0.001;
                            if (Math.abs(strafeMoveX) > minStrafeMove) aiPlayer.position.x += strafeMoveX;
                            if (Math.abs(strafeMoveZ) > minStrafeMove) aiPlayer.position.z += strafeMoveZ;
                            
                            // Check for collisions
                            if (checkAICollisions(aiPlayer)) {
                                aiPlayer.position.copy(oldStrafePosition);
                            }
                        }
                        break;
                        
                    case 'retreating':
                        // Move away from player
                        const retreatDir = new THREE.Vector3();
                        retreatDir.subVectors(aiPlayer.position, yawObject.position);
                        retreatDir.y = 0;
                        retreatDir.normalize();
                        
                        // Store current position for collision detection
                        const oldPosition = aiPlayer.position.clone();
                        
                        // Reset horizontal velocity
                        userData.velocity.x = 0;
                        userData.velocity.z = 0;
                        
                        // Set movement velocity based on direction - use same increased speed
                        const retreatSpeed = MOVE_SPEED * 2.5;
                        userData.velocity.x = retreatDir.x * retreatSpeed;
                        userData.velocity.z = retreatDir.z * retreatSpeed;
                        
                        // Apply movement - properly scaled by delta time
                        const deltaSeconds = delta / 1000;
                        const moveX = userData.velocity.x * deltaSeconds;
                        const moveZ = userData.velocity.z * deltaSeconds;
                        
                        // Apply movement with minimum threshold
                        const minMove = 0.001;
                        if (Math.abs(moveX) > minMove) aiPlayer.position.x += moveX;
                        if (Math.abs(moveZ) > minMove) aiPlayer.position.z += moveZ;
                        
                        // Check for collisions
                        if (checkAICollisions(aiPlayer)) {
                            aiPlayer.position.copy(oldPosition);
                            
                            // Try to find a new direction
                            setRandomPatrolTarget(aiPlayer);
                            userData.state = 'patrolling';
                        }
                        
                        // Occasionally shoot while retreating
                        if (Math.random() < 0.03 && checkLineOfSight(aiPlayer.position, yawObject.position)) {
                            aiShoot(aiPlayer, yawObject.position);
                        }
                        break;
                }
                
                // Check for projectile hits on AI players
                for (let j = projectiles.length - 1; j >= 0; j--) {
                    const projectile = projectiles[j];
                    
                    // Skip AI's own projectiles
                    if (projectile.userData.source === 'ai') continue;
                    
                    const distance = projectile.position.distanceTo(aiPlayer.position);
                    
                    // Use a reasonable hit radius
                    const hitRadius = 1.0;
                    
                    if (distance < hitRadius) {
                        // Hit an AI player
                        userData.health -= projectile.userData.damage;
                        
                        // Visual feedback for hit
                        userData.body.material.emissive = new THREE.Color(0xff0000);
                        setTimeout(() => {
                            userData.body.material.emissive = new THREE.Color(0x000000);
                        }, 100);
                        
                        // Create hit effect
                        createHitEffect(projectile.position);
                        
                        // Handle explosive projectiles
                        if (projectile.userData.explosive) {
                            createExplosion(projectile.position, projectile.userData.explosionRadius, projectile.userData.damage);
                        }
                        
                        // Remove tracer if exists
                        if (projectile.userData.tracer) {
                            scene.remove(projectile.userData.tracer);
                        }
                        
                        // Remove projectile
                        scene.remove(projectile);
                        projectiles.splice(j, 1);
                        
                        // Check if AI player is defeated
                        if (userData.health <= 0) {
                            // Add score
                            score += userData.scoreValue;
                            updateHUD();
                            
                            // Create score popup
                            createScorePopup(aiPlayer.position, userData.scoreValue);
                            
                            // Remove AI player
                            scene.remove(aiPlayer);
                            aiPlayers.splice(i, 1);
                            
                            // Respawn AI player after delay
                            setTimeout(() => {
                                createAIPlayer(
                                    (Math.random() - 0.5) * 80,
                                    (Math.random() - 0.5) * 80,
                                    'MEDIUM',
                                    userData.name
                                );
                            }, 5000);
                            
                            break; // Break the projectile loop since AI is removed
                        }
                    }
                }
            }
        }
        
        // Helper function to check if AI can see the target (line of sight)
        function checkLineOfSight(startPos, endPos) {
            // Create a ray from AI to target
            const direction = new THREE.Vector3();
            direction.subVectors(endPos, startPos);
            const distance = direction.length();
            direction.normalize();
            
            // Create a raycaster
            const raycaster = new THREE.Raycaster(startPos, direction, 0, distance);
            
            // Check for intersections with obstacles
            const intersects = raycaster.intersectObjects(
                obstacles.map(obstacle => obstacle.mesh),
                false
            );
            
            // If there are no intersections, we have line of sight
            return intersects.length === 0;
        }
        
        // Helper function to set a random patrol target for AI
        function setRandomPatrolTarget(aiPlayer) {
            // Choose a random position within the arena
            const x = (Math.random() - 0.5) * 90;
            const z = (Math.random() - 0.5) * 90;
            
            aiPlayer.userData.targetPosition.set(x, 1.6, z);
        }
        
        // Helper function to move AI toward a target position
        function moveAIToTarget(aiPlayer, targetPosition, delta) {
            const userData = aiPlayer.userData;
            
            // Apply gravity - use a smaller value to prevent floating
            userData.velocity.y -= GRAVITY * 1.5;
            
            // Update vertical position based on velocity
            aiPlayer.position.y += userData.velocity.y;
            
            // Check if AI is on the ground - use a more precise check
            if (aiPlayer.position.y <= 1.6) { // Same height as player
                userData.velocity.y = 0;
                aiPlayer.position.y = 1.6; // Force exact ground position
                userData.onGround = true;
            }
            
            // Calculate direction to target
            const direction = new THREE.Vector3();
            direction.subVectors(targetPosition, aiPlayer.position);
            direction.y = 0; // Keep on same y level
            
            // Check if we're close enough to target
            const distanceToTarget = direction.length();
            if (distanceToTarget < 1) {
                // We've reached the target
                if (userData.state === 'patrolling') {
                    // Set a new patrol target
                    setRandomPatrolTarget(aiPlayer);
                }
                return;
            }
            
            // Normalize direction
            direction.normalize();
            
            // Add some randomness to movement based on difficulty
            if (userData.difficulty.movementRandomness > 0) {
                direction.x += (Math.random() - 0.5) * userData.difficulty.movementRandomness;
                direction.z += (Math.random() - 0.5) * userData.difficulty.movementRandomness;
                direction.normalize();
            }
            
            // Store current position for collision detection
            const oldPosition = aiPlayer.position.clone();
            
            // Reset horizontal velocity
            userData.velocity.x = 0;
            userData.velocity.z = 0;
            
            // Set movement velocity based on direction - increase base speed
            const baseSpeed = MOVE_SPEED * 2.5; // Increase base speed
            userData.velocity.x = direction.x * baseSpeed;
            userData.velocity.z = direction.z * baseSpeed;
            
            // Apply movement - properly scaled by delta time
            // Convert delta from milliseconds to seconds for consistent movement speed
            const deltaSeconds = delta / 1000;
            const moveX = userData.velocity.x * deltaSeconds;
            const moveZ = userData.velocity.z * deltaSeconds;
            
            // Apply movement with a minimum threshold to ensure movement happens
            const minMove = 0.001; // Minimum movement threshold
            if (Math.abs(moveX) > minMove) aiPlayer.position.x += moveX;
            if (Math.abs(moveZ) > minMove) aiPlayer.position.z += moveZ;
            
            // Debug movement info
            if (debugMode) {
                console.log(`AI movement: deltaSeconds=${deltaSeconds.toFixed(4)}, moveX=${moveX.toFixed(4)}, moveZ=${moveZ.toFixed(4)}`);
            }
            
            // Rotate AI to face movement direction
            const targetRotation = Math.atan2(direction.x, direction.z);
            
            // Smooth rotation
            const rotationDiff = targetRotation - aiPlayer.rotation.y;
            
            // Normalize rotation difference to [-PI, PI]
            let normalizedDiff = rotationDiff;
            while (normalizedDiff > Math.PI) normalizedDiff -= Math.PI * 2;
            while (normalizedDiff < -Math.PI) normalizedDiff += Math.PI * 2;
            
            // Apply smooth rotation
            aiPlayer.rotation.y += normalizedDiff * 0.1;
            
            // Check for collisions
            if (checkAICollisions(aiPlayer)) {
                // Collision detected, revert position
                aiPlayer.position.copy(oldPosition);
                
                // Try a different direction
                if (Math.random() < 0.3) {
                    setRandomPatrolTarget(aiPlayer);
                }
            }
            
            // Simple boundary checks
            if (aiPlayer.position.x < -48) aiPlayer.position.x = -48;
            if (aiPlayer.position.x > 48) aiPlayer.position.x = 48;
            if (aiPlayer.position.z < -48) aiPlayer.position.z = -48;
            if (aiPlayer.position.z > 48) aiPlayer.position.z = 48;
        }
        
        // Helper function to check AI collisions with obstacles
        function checkAICollisions(aiPlayer) {
            // AI collision radius
            const aiRadius = 0.5;
            const aiPos = aiPlayer.position;
            
            // Check each obstacle
            for (let i = 0; i < obstacles.length; i++) {
                const obstacle = obstacles[i];
                
                // Simple box-sphere collision detection
                // Calculate closest point on box to AI
                const closestX = Math.max(obstacle.x - obstacle.width/2, Math.min(aiPos.x, obstacle.x + obstacle.width/2));
                const closestY = Math.max(obstacle.y - obstacle.height/2, Math.min(aiPos.y, obstacle.y + obstacle.height/2));
                const closestZ = Math.max(obstacle.z - obstacle.depth/2, Math.min(aiPos.z, obstacle.z + obstacle.depth/2));
                
                // Calculate distance from closest point to AI center
                const distanceX = closestX - aiPos.x;
                const distanceY = closestY - aiPos.y;
                const distanceZ = closestZ - aiPos.z;
                
                const distanceSquared = distanceX * distanceX + distanceY * distanceY + distanceZ * distanceZ;
                
                // Check if distance is less than AI radius
                if (distanceSquared < aiRadius * aiRadius) {
                    return true; // Collision detected
                }
            }
            
            return false; // No collision
        }
        
        // Helper function to check if AI can pick up items
        function checkAIPickupCollisions(aiPlayer) {
            const userData = aiPlayer.userData;
            
            for (let i = pickups.length - 1; i >= 0; i--) {
                const pickup = pickups[i];
                const distance = pickup.position.distanceTo(aiPlayer.position);
                
                if (distance < 2) {
                    if (pickup.userData.type === 'weapon') {
                        // Add ammo for weapon
                        const weaponType = pickup.userData.weaponType;
                        userData.weapons[weaponType].ammo = userData.weapons[weaponType].maxAmmo;
                        
                        // Switch to the weapon if it's better than current
                        if (weaponType === 'rocketLauncher' || 
                            (weaponType === 'shotgun' && userData.weapons.blaster.active)) {
                            userData.switchWeapon(weaponType);
                        }
                        
                        // Remove pickup
                        scene.remove(pickup);
                        pickups.splice(i, 1);
                        
                        // Respawn pickup after delay
                        setTimeout(() => {
                            const newPickup = createWeaponPickup(
                                weaponType, 
                                pickup.position.x, 
                                pickup.position.z
                            );
                        }, 10000);
                    }
                }
            }
        }
        
        // Debug direction indicator
        let directionIndicator = null;
        
        function updateDebugDirectionIndicator() {
            // Only show in debug mode
            if (debugMode) {
                if (!directionIndicator) {
                    // Create a line showing the shooting direction
                    const lineGeometry = new THREE.BufferGeometry();
                    const lineMaterial = new THREE.LineBasicMaterial({ 
                        color: 0xff0000,
                        linewidth: 3
                    });
                    
                    directionIndicator = new THREE.Line(lineGeometry, lineMaterial);
                    scene.add(directionIndicator);
                }
                
                // Update the line to match current camera direction
                const startPoint = new THREE.Vector3();
                startPoint.copy(camera.position);
                startPoint.add(yawObject.position);
                
                const direction = new THREE.Vector3();
                camera.getWorldDirection(direction);
                
                const endPoint = startPoint.clone().add(
                    direction.multiplyScalar(10) // Show 10 units ahead
                );
                
                const points = [startPoint, endPoint];
                directionIndicator.geometry.dispose();
                directionIndicator.geometry = new THREE.BufferGeometry().setFromPoints(points);
            } else if (directionIndicator) {
                // Remove when debug mode is off
                scene.remove(directionIndicator);
                directionIndicator = null;
            }
        }
        
        // Create a position display element
        let positionDisplay = null;
        
        function updatePositionDisplay() {
            if (!positionDisplay) {
                positionDisplay = document.createElement('div');
                positionDisplay.style.position = 'absolute';
                positionDisplay.style.bottom = '10px';
                positionDisplay.style.right = '10px';
                positionDisplay.style.color = 'white';
                positionDisplay.style.backgroundColor = 'rgba(0,0,0,0.5)';
                positionDisplay.style.padding = '5px';
                positionDisplay.style.borderRadius = '3px';
                positionDisplay.style.fontSize = '12px';
                positionDisplay.style.fontFamily = 'monospace';
                positionDisplay.style.zIndex = '100';
                document.body.appendChild(positionDisplay);
            }
            
            // Round position values to 2 decimal places for readability
            const x = Math.round(yawObject.position.x * 100) / 100;
            const y = Math.round(yawObject.position.y * 100) / 100;
            const z = Math.round(yawObject.position.z * 100) / 100;
            
            positionDisplay.textContent = `Position: (${x}, ${y}, ${z})`;
        }
        
        function startGame() {
            console.log("Starting game");
            gameStarted = true;
            document.getElementById('start-menu').style.display = 'none';
            
            // Set initial target rotations
            targetYaw = 0;
            targetPitch = 0;
            currentYaw = 0;
            currentPitch = 0;
            
            // Request pointer lock on game start
            const canvas = document.getElementById('gameCanvas');
            canvas.requestPointerLock = canvas.requestPointerLock || 
                                       canvas.mozRequestPointerLock ||
                                       canvas.webkitRequestPointerLock;
            setTimeout(() => {
                canvas.requestPointerLock();
            }, 100);
            
            // Start the animation loop if not already running
            if (!frameId) {
                prevTime = performance.now();
                animate();
            }
            
            // Update the HUD
            updateHUD();
            
            // Display control instructions
            displayFallbackMessage();
            
            // Add keyboard focus to the canvas
            const canvasFocus = document.getElementById('gameCanvas');
            canvasFocus.focus();
            canvasFocus.setAttribute('tabindex', '0');
            console.log("Canvas focused:", document.activeElement === canvasFocus);
            
            // Force movement variables to false to ensure clean state
            moveForward = false;
            moveBackward = false;
            moveLeft = false;
            moveRight = false;
            
            // Test keyboard controls
            testKeyboardControls();
            
            // Display version and collision info
            displayVersionInfo();
        }
        
        function displayVersionInfo() {
            const versionInfo = document.createElement('div');
            versionInfo.style.position = 'absolute';
            versionInfo.style.top = '30px';
            versionInfo.style.left = '10px';
            versionInfo.style.color = 'lime';
            versionInfo.style.backgroundColor = 'rgba(0,0,0,0.5)';
            versionInfo.style.padding = '10px';
            versionInfo.style.borderRadius = '5px';
            versionInfo.style.zIndex = '50';
            versionInfo.style.pointerEvents = 'none';
            versionInfo.innerHTML = `Version: ${GAME_VERSION}<br>Collision radius: 0.2<br>Wall sliding enabled`;
            document.body.appendChild(versionInfo);
            
            // Remove after 10 seconds
            setTimeout(() => {
                document.body.removeChild(versionInfo);
            }, 10000);
        }
        
        function testKeyboardControls() {
            console.log("Testing keyboard controls...");
            console.log("Current movement state:", {
                moveForward,
                moveBackward,
                moveLeft,
                moveRight
            });
            console.log("Press WASD or arrow keys to move");
            
            // Create a temporary indicator to show keyboard status
            const keyboardStatus = document.createElement('div');
            keyboardStatus.style.position = 'absolute';
            keyboardStatus.style.top = '120px';
            keyboardStatus.style.left = '10px';
            keyboardStatus.style.color = 'lime';
            keyboardStatus.style.backgroundColor = 'rgba(0,0,0,0.5)';
            keyboardStatus.style.padding = '10px';
            keyboardStatus.style.borderRadius = '5px';
            keyboardStatus.style.zIndex = '50';
            keyboardStatus.style.pointerEvents = 'none';
            keyboardStatus.innerHTML = 'Keyboard Controls: Active';
            document.body.appendChild(keyboardStatus);
            
            // Remove after 5 seconds
            setTimeout(() => {
                document.body.removeChild(keyboardStatus);
            }, 5000);
        }
        
        function gameOver() {
            gameStarted = false;
            
            document.getElementById('game-over').style.display = 'flex';
            document.querySelector('.final-score').textContent = `Final Score: ${score}`;
        }
        
        function restartGame() {
            // Reset game state
            health = 100;
            score = 0;
            
            // Reset player position
            yawObject.position.set(-10, 1.6, -10);
            
            // Clear existing enemies and projectiles
            for (let i = enemies.length - 1; i >= 0; i--) {
                scene.remove(enemies[i]);
            }
            enemies = [];
            
            for (let i = projectiles.length - 1; i >= 0; i--) {
                scene.remove(projectiles[i]);
            }
            projectiles = [];
            
            // Clear existing AI players
            for (let i = aiPlayers.length - 1; i >= 0; i--) {
                scene.remove(aiPlayers[i]);
            }
            aiPlayers = [];
            
            // Reset weapons
            weapons.blaster.ammo = weapons.blaster.maxAmmo;
            weapons.shotgun.ammo = 0;
            weapons.rocketLauncher.ammo = 0;
            switchWeapon('blaster');
            
            // Hide game over screen
            document.getElementById('game-over').style.display = 'none';
            
            // Recreate enemies
            createEnemy(-35, -35);
            createEnemy(35, 35);
            createEnemy(-35, 35);
            createEnemy(0, -35);
            
            // Add AI players based on UI settings
            const aiCount = parseInt(document.getElementById('ai-count').value) || 0;
            const aiDifficulty = document.getElementById('ai-difficulty').value || 'MEDIUM';
            
            // Create AI players at different positions
            const aiPositions = [
                [30, -30],
                [-30, 30],
                [30, 30],
                [-30, -30]
            ];
            
            for (let i = 0; i < aiCount; i++) {
                if (i < aiPositions.length) {
                    createAIPlayer(
                        aiPositions[i][0], 
                        aiPositions[i][1], 
                        aiDifficulty, 
                        `Bot-${i+1}`
                    );
                }
            }
            
            // Update HUD
            updateHUD();
            
            // Restart game
            gameStarted = true;
        }
        
        function displayFallbackMessage() {
            const fallbackMsg = document.createElement('div');
            fallbackMsg.style.position = 'absolute';
            fallbackMsg.style.top = '70px';
            fallbackMsg.style.left = '10px';
            fallbackMsg.style.color = 'yellow';
            fallbackMsg.style.backgroundColor = 'rgba(0,0,0,0.5)';
            fallbackMsg.style.padding = '10px';
            fallbackMsg.style.borderRadius = '5px';
            fallbackMsg.style.zIndex = '50';
            fallbackMsg.style.pointerEvents = 'none';
            fallbackMsg.innerHTML = 'WASD or Arrow Keys to move | SPACE to jump | Move mouse to aim | Click to shoot | 1-3 to switch weapons | 0 or ` to toggle debug';
            document.body.appendChild(fallbackMsg);
        }
        
        // Add a function to create hit effects
        function createHitEffect(position) {
            // Create a particle effect at hit position
            const particleGeometry = new THREE.BufferGeometry();
            const particleCount = 10;
            const positions = new Float32Array(particleCount * 3);
            
            for (let i = 0; i < particleCount * 3; i += 3) {
                positions[i] = position.x + (Math.random() - 0.5) * 0.5;
                positions[i + 1] = position.y + (Math.random() - 0.5) * 0.5;
                positions[i + 2] = position.z + (Math.random() - 0.5) * 0.5;
            }
            
            particleGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            
            const particleMaterial = new THREE.PointsMaterial({
                color: 0xffff00,
                size: 0.1,
                transparent: true,
                opacity: 0.8
            });
            
            const particles = new THREE.Points(particleGeometry, particleMaterial);
            scene.add(particles);
            
            // Fade out and remove after a short time
            let opacity = 0.8;
            const fadeInterval = setInterval(() => {
                opacity -= 0.1;
                particleMaterial.opacity = opacity;
                
                if (opacity <= 0) {
                    clearInterval(fadeInterval);
                    scene.remove(particles);
                }
            }, 50);
        }
        
        // Function to toggle debug mode
        function toggleDebugMode() {
            debugMode = !debugMode;
            console.log("Debug mode:", debugMode ? "ON" : "OFF");
            updateHUD();
            
            // Update debug button text
            const debugButton = document.getElementById('debug-toggle-button');
            if (debugButton) {
                debugButton.textContent = debugMode ? "Debug: ON" : "Debug: OFF";
                debugButton.style.backgroundColor = debugMode ? "#00aa00" : "#555555";
            }
        }
        
        // Create a button to toggle debug mode
        function createDebugToggleButton() {
            const debugButton = document.createElement('button');
            debugButton.id = 'debug-toggle-button';
            debugButton.textContent = "Debug: OFF";
            debugButton.style.position = 'absolute';
            debugButton.style.top = '10px';
            debugButton.style.right = '10px';
            debugButton.style.padding = '5px 10px';
            debugButton.style.backgroundColor = '#555555';
            debugButton.style.color = 'white';
            debugButton.style.border = 'none';
            debugButton.style.borderRadius = '5px';
            debugButton.style.cursor = 'pointer';
            debugButton.style.zIndex = '1000';
            
            debugButton.addEventListener('click', function() {
                toggleDebugMode();
            });
            
            document.body.appendChild(debugButton);
            
            // Also create a help button
            const helpButton = document.createElement('button');
            helpButton.id = 'help-button';
            helpButton.textContent = "Help";
            helpButton.style.position = 'absolute';
            helpButton.style.top = '10px';
            helpButton.style.right = '100px';
            helpButton.style.padding = '5px 10px';
            helpButton.style.backgroundColor = '#4CAF50';
            helpButton.style.color = 'white';
            helpButton.style.border = 'none';
            helpButton.style.borderRadius = '5px';
            helpButton.style.cursor = 'pointer';
            helpButton.style.zIndex = '1000';
            
            helpButton.addEventListener('click', function() {
                // Open instructions in a new tab
                window.open('instructions.html', '_blank');
            });
            
            document.body.appendChild(helpButton);
        }
        
        // Initialize the game
        init();
        
        function aiShoot(aiPlayer, targetPosition) {
            const userData = aiPlayer.userData;
            const weapon = userData.getActiveWeapon();
            const now = performance.now();
            
            // Check fire rate and ammo
            if (now - userData.lastShotTime < 1000 / weapon.fireRate || 
                (weapon.name !== "Basic Blaster" && weapon.ammo <= 0)) {
                return;
            }
            
            userData.lastShotTime = now;
            
            // Reduce ammo (except for blaster which has infinite ammo)
            if (weapon.name !== "Basic Blaster") {
                weapon.ammo--;
            }
            
            // Create projectiles based on weapon type
            for (let i = 0; i < weapon.projectileCount; i++) {
                // Create projectile
                const projectileGeometry = new THREE.SphereGeometry(weapon.projectileSize, 8, 8);
                const projectileMaterial = new THREE.MeshBasicMaterial({ color: weapon.projectileColor });
                const projectile = new THREE.Mesh(projectileGeometry, projectileMaterial);
                
                // Position at AI weapon position
                const weaponWorldPosition = new THREE.Vector3();
                userData.weapon.getWorldPosition(weaponWorldPosition);
                projectile.position.copy(weaponWorldPosition);
                
                // Calculate direction to target
                const direction = new THREE.Vector3();
                direction.subVectors(targetPosition, projectile.position);
                direction.normalize();
                
                // Apply accuracy based on difficulty
                const accuracy = userData.difficulty.accuracy;
                if (accuracy < 1) {
                    // Add random deviation based on accuracy
                    const deviation = (1 - accuracy) * 0.5;
                    direction.x += (Math.random() - 0.5) * deviation;
                    direction.y += (Math.random() - 0.5) * deviation;
                    direction.z += (Math.random() - 0.5) * deviation;
                    direction.normalize();
                }
                
                // Add spread for shotgun
                if (weapon.spread) {
                    const spread = weapon.spread;
                    direction.x += (Math.random() - 0.5) * spread;
                    direction.y += (Math.random() - 0.5) * spread;
                    direction.z += (Math.random() - 0.5) * spread;
                    direction.normalize();
                }
                
                // Store projectile data
                projectile.userData = {
                    type: 'projectile',
                    source: 'ai',
                    direction: direction,
                    speed: weapon.projectileSpeed,
                    damage: weapon.damage,
                    timeCreated: now,
                    explosive: weapon.explosive || false,
                    explosionRadius: weapon.explosionRadius || 0
                };
                
                // Add to scene and tracking array
                scene.add(projectile);
                projectiles.push(projectile);
                
                // Add tracer line for debug mode
                if (debugMode) {
                    const tracerGeometry = new THREE.BufferGeometry();
                    const tracerMaterial = new THREE.LineBasicMaterial({ 
                        color: weapon.projectileColor,
                        transparent: true,
                        opacity: 0.5
                    });
                    
                    // Create a line showing the projectile's path
                    const startPoint = projectile.position.clone();
                    const endPoint = startPoint.clone().add(
                        direction.clone().multiplyScalar(50) // Show 50 units ahead
                    );
                    
                    const points = [startPoint, endPoint];
                    tracerGeometry.setFromPoints(points);
                    
                    const tracer = new THREE.Line(tracerGeometry, tracerMaterial);
                    tracer.userData = { type: 'tracer', timeCreated: now };
                    scene.add(tracer);
                    
                    // Store tracer reference in projectile for cleanup
                    projectile.userData.tracer = tracer;
                }
            }
            
            // Create muzzle flash effect for AI
            createAIMuzzleFlash(aiPlayer);
        }
        
        function createAIMuzzleFlash(aiPlayer) {
            const userData = aiPlayer.userData;
            
            // Create a point light for muzzle flash
            const muzzleLight = new THREE.PointLight(0xffff00, 3, 2);
            
            // Position the light at the end of the weapon
            const weaponWorldPosition = new THREE.Vector3();
            userData.weapon.getWorldPosition(weaponWorldPosition);
            muzzleLight.position.copy(weaponWorldPosition);
            
            // Add to scene
            scene.add(muzzleLight);
            
            // Remove the light after a short delay
            setTimeout(() => {
                scene.remove(muzzleLight);
            }, 50);
            
            // Also add a visual flash effect
            const flashGeometry = new THREE.SphereGeometry(0.05, 8, 8);
            const flashMaterial = new THREE.MeshBasicMaterial({ 
                color: 0xffff00,
                transparent: true,
                opacity: 0.8
            });
            const flashMesh = new THREE.Mesh(flashGeometry, flashMaterial);
            flashMesh.position.copy(weaponWorldPosition);
            
            scene.add(flashMesh);
            
            // Animate and remove the flash
            setTimeout(() => {
                scene.remove(flashMesh);
            }, 50);
        }
    </script>
</body>
</html>

